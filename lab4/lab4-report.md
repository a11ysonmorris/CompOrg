Lab 4 â€” Sum-of-Squares (sos): Technique Report

This lab introduced the full pipeline from C source code to assembly and machine code, giving practical experience with compilation, calling conventions, and disassembly. Working through the sum-of-squares example clarified how high-level constructs such as function calls, arithmetic, and variable storage are implemented at the assembly level. Analyzing the hand-written assembly emphasized stack frames: the callee prologue (`pushl %ebp`, `movl %esp, %ebp`), local variable allocation, and the epilogue (`leave`, `ret`). Writing assembly by hand was instructive because it made explicit the placement of arguments, the return address, and saved registers.

Compiling `sos.c` with `gcc -S -m32` produced `sos.s`, which uses the same calling convention but differs in register saving and stack management details; for example, the compiler inserts pushes for callee-saved registers and stack alignment in `main`. These variations highlight that multiple correct assembly implementations can realize the same high-level semantics. Using `-O3` showed obvious optimizations: the optimized `sos_O3.s` reduces frame set-up and uses register arithmetic to compute `sq` and `sos` with fewer memory operations, demonstrating how compilers trade off code complexity for speed and compactness.

Finally, disassembling the compiled binary with GDB (`disassemble sq`, `disassemble sos`) confirmed that the machine instructions correspond to the unoptimized assembly patterns. The disassembly output is included in `gdb-output.txt`. Overall, the lab reinforced how high-level programming maps to low-level execution and how tools (gcc, gdb) reveal the translator's choices and optimizations.
