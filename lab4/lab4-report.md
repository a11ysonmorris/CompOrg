Lab 4 Sum-of-Squares (sos) Report

This lab introduced us to the full pipeline from C source code to assembly and machine code, ultimately giving practical experience with compilation, calling conventions, and disassembly. Working through the sum-of-squares example made it clear how high-level constructs, such as function calls, arithmetic, and variable storage, are implemented at the assembly level. By analyzing the hand-written assembly, we could see how it emphasized stack frames: the callee prologue (`pushl %ebp`, `movl %esp, %ebp`), local variable allocation, and the epilogue (`leave`, `ret`). Writing assembly by hand was instructive because it made clear the placement of arguments, the return address, and saved registers.

Compiling `sos.c` with `gcc -S -m32` produced `sos.s`, which uses the same calling convention but differs in register saving and stack management details; for example, the compiler inserts pushes for callee-saved registers and stack alignment in `main`. These variations highlight that multiple correct assembly implementations can be used to realize the same high-level semantics. Using `-O3` showed obvious, clear benefits: the optimized `sos_O3.s` reduces frame setup and uses register arithmetic to compute `sq` and `sos` with fewer memory operations, demonstrating how compilers trade off code complexity for speed and compactness.

Finally, disassembling the compiled binary with GDB (`disassemble sq`, `disassemble sos`) confirmed that the machine instructions correspond to the unoptimized assembly patterns. The disassembly output is included in `gdb-output.txt`. Overall, the lab reinforced how high-level programming maps to low-level execution and how tools (gcc, gdb) reveal the translator's choices and optimizations.
